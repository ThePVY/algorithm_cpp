/*!\file
 * \brief Этот файл содержит структуры, макросы и функции, необходимые для взаимодействия с аппаратным модулем GPIO.
 *
 * Copyright(C) НПП Цифровые решения, 2018
 * Copyright(C) Команда разработчиков НПП Цифровые решения
 * Все права защищены.
 *
 * Программное обеспечение, описанное в этом файле, предназначено только для 
 * демонстрационных целей, и предоставляет программистам информацию о продукции 
 * организации "Цифровые решения". Это программное обеспечение поставляется "КАК ЕСТЬ" 
 * без каких-либо гарантий, "Цифровые решения" отказываются от любых гарантий, 
 * фактических или подразумеваемых, включая все подразумеваемые гарантии товарной пригодности, 
 * пригодности для конкретной цели и сохранения прав интеллектуальной собственности. 
 * Организация "Цифровые решения" не несет никакой ответственности за использование 
 * программного обеспечения, не предоставляет лицензий или прав на патент, авторское право, 
 * или любые другие права интеллектуальной собственности, на какие-либо продукты. 
 * Организация "Цифровые решения" оставляет за собой право вносить изменения в программное 
 * обеспечение без уведомления. Организация "Цифровые решения" также не дает никаких 
 * заверений или гарантий, что это программное приложение подойдет для использования 
 * без дальнейшего тестирования или модификаций.
 *
 * Разрешение на использование, копирование, изменение и распространение этого программного 
 * обеспечения и документации предоставляется согласно условиям "Цифровых решений" и 
 * соответствующих авторских прав своей лицензии без оплаты, при условии, 
 * что это программное обеспечение используется совместно с микроконтроллерами организации
 * "Цифровые решения". Эти права должны распространяться во всех копиях этого кода.
 */

#ifndef GPIO_H_
#define GPIO_H_

// gf_ver 2.2.0

#include "types.h"

/**
 * @brief Структура для доступа к регистрам GPIO.
 */
typedef struct 
{
    __RW uint32_t  DATA;                                                        /**< Смещение: 0x0000 Регистр для чтения данных на входе порта */ 
    __RW uint32_t  DATAOUT;                                                     /**< Смещение: 0x0004 Регистр для записи выходных данных на выход порта */ 
    __RW uint32_t  RESERVED0[2];                                                /**< Резерв*/
    __RW uint32_t  OUTENSET;                                                    /**< Смещение: 0x0010 Регистр для установки вывода в режим выхода*/
    __RW uint32_t  OUTENCLR;                                                    /**< Смещение: 0x0014 Регист для сброса вывода в режим входа */
    __RW uint32_t  ALTFUNCSET;                                                  /**< Смещение: 0x0018 Регистр для перевода вывода в режим альтернативной функции*/
    __RW uint32_t  ALTFUNCCLR;                                                  /**< Смещение: 0x001C Регистр для сброса вывода в режим GPIO*/
    __RW uint32_t  INTENSET;                                                    /**< Смещение: 0x0020 Регистр для разрешения прерываний */
    __RW uint32_t  INTENCLR;                                                    /**< Смещение: 0x0024 Регистр для сброса разрешения прерываний */
    __RW uint32_t  INTTYPESET;                                                  /**< Смещение: 0x0028 Регистр для установки типа прерываний: */
    __RW uint32_t  INTTYPECLR;                                                  /**< Смещение: 0x002C Регистр для сброса типа прерываний */
    __RW uint32_t  INTPOLSET;                                                   /**< Смещение: 0x0030 Регистр для установки полярности события прерывания */ 
    __RW uint32_t  INTPOLCLR;                                                   /**< Смещение: 0x0034 Регистр для сброса полярности события прерываний */
    __RW uint32_t  INTSTATUS;                                                   /**< Смещение: 0x0038 Регистр для чтения/сброса статуса прерываний */
    __RW uint32_t  RESERVED1[241];                                              ///< Резерв
    __RW uint32_t  MASKLOWBYTE[256];                                              /**< Смещение: 0x0400 - 0x07FC Адресное пространство доступа по маске для младших 8-ми бит */
    __RW uint32_t  MASKHIGHBYTE[256];                                              /**< Смещение: 0x0800 - 0x0BFC Адресное пространство доступа по маске для старших 8-ми бит */
}GPIO_T;

/**
 * @brief Тип - профиль для установки типа и полярности события прерывания.
 */
typedef enum GPIOPINT_MODE 
{
    GPIOPINT_FRONT_LOW      = 0x00,                                             /**< b'00': срабатывание по уровню - низкий уровень */
    GPIOPINT_FALLING_EDGE   = 0x01,                                             /**< b'01': срабатывание по фронту - отрицательный фронт */
    GPIOPINT_FRONT_HIGHT    = 0x02,                                             /**< b'10': срабатывание по уровню - высокий уровень */
    GPIOPINT_RISING_EDGE    = 0x03,                                             /**< b'11': срабатывание по фронту - положительный фронт */
}GPIOPINT_MODE_T;

/**
 * @brief Макросы для работы GPIO
 */

/** Включение прерываний GPIO */   
#define	GPIO_IntEnable(gl_gpio_t, gl_gpio_pin) (((GPIO_T*)(gl_gpio_t))->INTENSET = (1<<gl_gpio_pin))

/** Выключение прерываний GPIO */   
#define	GPIO_IntDisable(gl_gpio_t, gl_gpio_pin) (((GPIO_T*)(gl_gpio_t))->INTENCLR = (1<<gl_gpio_pin))

/** Сбросить прерывание GPIO */   
#define	GPIO_IntClear(gl_gpio_t, gl_gpio_pin) (((GPIO_T*)(gl_gpio_t))->INTSTATUSCLEAR = (1<<gl_gpio_pin))

/**
 * @brief Сконфигурировать вывод порта GPIO
 * @param pGPIO: указатель на структуру с регистрами GPIO.
 * @param Pin_number: номер вывода (0..15).
 * @param Dir: тип конфигурации   
 *         Параметр Dir может принимать значения:
 *          @arg true: сконфигурировать на выход 
 *          @arg false: сконфигурировать на вход
 * @retval None.
 */
void GPIO_WriteDirBit(GPIO_T *pGPIO, uint8_t Pin_number, bool Dir);

 /**
 * @brief Установить режим GPIO или режим альтернативной функции.
 * @param pGPIO: указатель на структуру с регистрами GPIO.
 * @param Pin_number: номер вывода (0..15).
 * @param AltSet: установка режима. 
 *         Параметр AltSet может принимать значения:
 *          @arg true: режим альтернативной функции, 
 *          @arg false: режим GPIO
 * @retval None.
 */
void GPIO_SetAltFunc(GPIO_T *pGPIO, uint16_t Pin_number, bool AltSet);

 /**
 * @brief Запись данных в порт GPIO.
 * @param pGPIO: указатель на структуру с регистрами GPIO.
 * @param mask: Маска соответствует выводам на порте, если бит в маске равен 1, 
 *              то состояние соответствующего вывода на порте будет обновлено.
 * @param val: значение записываемое в порт. 
 * @retval None.
 */
void GPIO_WritePort(GPIO_T *pGPIO, uint16_t mask, uint16_t val);

 /**
 * @brief Установка состояния на выводе порта GPIO.
 * @param pGPIO: указатель на структуру с регистрами GPIO.
 * @param pin: номер вывода (0..15).
 * @param val: значение состояния. 
 *         Параметр val может принимать значения:
 *          @arg true: высокое состояние, 
 *          @arg false: низкое состояние
 * @retval None.
 */
void GPIO_WritePortBit(GPIO_T *pGPIO, uint8_t pin, bool val);

/**
 * @brief Считать состояние выводов сконфигурированных на выход	
 * @param pGPIO: указатель на структуру с регистрами GPIO.
 * @retval Текущее состояние выводов
 */
uint32_t GPIOOUT_ReadPort(GPIO_T *pGPIO);

/**
 * @brief Считать состояние выводов сконфигурированных на вход	
 * @param pGPIO: указатель на структуру с регистрами GPIO.
 * @retval Текущее состояние выводов
 */
uint32_t GPIOIN_ReadPort(GPIO_T *pGPIO);

/**
 * @brief Считать состояние вывода сконфигурированого на выход
 * @param pGPIO: указатель на структуру с регистрами GPIO.
 * @param pin: номер вывода (0..15).
 * @retval Текущее состояние вывода: true - высокое, false - низкое
 */
bool GPIOOUT_ReadPortBit(GPIO_T *pGPIO, uint8_t pin);

/**
 * @brief Считать состояние вывода сконфигурированного на вход 
 * @param pGPIO: указатель на структуру с регистрами GPIO.
 * @param pin: номер вывода (0..15).
 * @retval Текущее состояние вывода: true - высокое, false - низкое
 */
bool GPIOIN_ReadPortBit(GPIO_T *pGPIO, uint8_t pin);

/**
 * @brief Считать конфигурацию вывода GPIO
 * @param pGPIO: указатель на структуру с регистрами GPIO.
 * @param pin: номер вывода (0..15).
 * @retval Текущая конфигурация вывода: true - на выход, false - на вход
 */
bool GPIO_ReadDirBit(GPIO_T *pGPIO, uint8_t pin);

/**
 * @brief Считать конфигурацию выводов GPIO
 * @param pGPIO: указатель на структуру с регистрами GPIO.
 * @retval Текущее значение регистра OUTENSET
 */
uint32_t GPIO_GetDir(GPIO_T *pGPIO);

/**
 * @brief Считать установленный режим
 * @note  Выбран режим GPIO или режим альтернативной функции
 * @param pGPIO: указатель на структуру с регистрами GPIO.
 * @retval Текущее значение регистра ALTFUNCSET
 */
uint32_t GPIO_GetAltFunc(GPIO_T *pGPIO);

/**
 * @brief Настроить профиль прерывания.
 * @param pGPIO: указатель на структуру с регистрами GPIO.
 * @param Pin_number: номер вывода (0..15).
 * @param IntMode: профиль настройки прерывания.
 *         Параметр GPIOPINT_MODE_T может принимать значения:
 *          @arg GPIOPINT_FRONT_HIGHT: работа по уровню, высокий логический уровень
 *          @arg GPIOPINT_FRONT_LOW: работа по уровню, низкий логический уровень
 *          @arg GPIOPINT_RISING_EDGE: работа по фронту, высокий логический уровень
 *          @arg GPIOPINT_FALLING_EDGE: работа по фронту, низкий логический уровень
 * @retval None.
 */
void GPIO_IntConfig(GPIO_T *pGPIO, uint32_t Pin_number, GPIOPINT_MODE_T IntMode);

/**
 * @brief Взять текущий статус прерываня для каждого вывода
 * @param pGPIO: указатель на структуру с регистрами GPIO.
 * @retval Текущий статус прерываний
 */
uint32_t GPIO_IntGetStatus(GPIO_T *pGPIO);

/**
 * @brief Взять текущий профиль прерывания для вывода
 * @param pGPIO: указатель на структуру с регистрами GPIO.
 * @param pin: номер вывода (0..15).
 * @retval Текущий профиль прерывания
 */ 
GPIOPINT_MODE_T GPIO_GetIntConfigPin(GPIO_T *pGPIO, uint8_t pin);        



#endif /* GPIO_H */
