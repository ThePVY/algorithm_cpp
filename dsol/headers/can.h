/*!\file
 * \brief Этот файл содержит структуры, макросы и функции, необходимые для взаимодействия с интерфесом CAN.
 *
 * Copyright(C) НПП Цифровые решения, 2018
 * Copyright(C) Команда разработчиков НПП Цифровые решения
 * Все права защищены.
 *
 * Программное обеспечение, описанное в этом файле, предназначено только для 
 * демонстрационных целей, и предоставляет программистам информацию о продукции 
 * организации "Цифровые решения". Это программное обеспечение поставляется "КАК ЕСТЬ" 
 * без каких-либо гарантий, "Цифровые решения" отказываются от любых гарантий, 
 * фактических или подразумеваемых, включая все подразумеваемые гарантии товарной пригодности, 
 * пригодности для конкретной цели и сохранения прав интеллектуальной собственности. 
 * Организация "Цифровые решения" не несет никакой ответственности за использование 
 * программного обеспечения, не предоставляет лицензий или прав на патент, авторское право, 
 * или любые другие права интеллектуальной собственности, на какие-либо продукты. 
 * Организация "Цифровые решения" оставляет за собой право вносить изменения в программное 
 * обеспечение без уведомления. Организация "Цифровые решения" также не дает никаких 
 * заверений или гарантий, что это программное приложение подойдет для использования 
 * без дальнейшего тестирования или модификаций.
 *
 * Разрешение на использование, копирование, изменение и распространение этого программного 
 * обеспечения и документации предоставляется согласно условиям "Цифровых решений" и 
 * соответствующих авторских прав своей лицензии без оплаты, при условии, 
 * что это программное обеспечение используется совместно с микроконтроллерами организации
 * "Цифровые решения". Эти права должны распространяться во всех копиях этого кода.
 */

#ifndef CAN_H
#define CAN_H

#include "types.h"



/**
 * @brief Структура для доступа к регистрам контроллера CAN в базовом режиме.
 */
typedef struct
{
    __RW uint32_t CONTROL;                                                      /**< Смещение: 0x00 Контрольный регистр */
    __WO uint32_t COMMAND;                                                      /**< Смещение: 0x04 Регистр команд */
    __RO uint32_t STATUS;                                                       /**< Смещение: 0x08 Регистр статуса */
    __RO uint32_t INTERRUPT;                                                    /**< Смещение: 0x0C Регистр прерываний */
    __RW uint32_t ACEPTANCE_CODE;                                               /**< Смещение: 0x10 Регистр приемного кода. Только в состоянии сброса */
    __RW uint32_t ACEPTANCE_MASK;                                               /**< Смещение: 0x14 Регистр приемной маски. Только в состоянии сброса */
    __RW uint32_t BUS_TIMING_0;                                                 /**< Смещение: 0x18 Первый регистр временных параметров шины. Только в состоянии сброса */
    __RW uint32_t BUS_TIMING_1;                                                 /**< Смещение: 0x1C Второй регистр временных параметров шины. Только в состоянии сброса */
    uint32_t reserved[2];                                                       /**< Резерв*/
    __RW uint32_t TX_id1;                                                       /**< Смещение: 0x28 Первый регистр заголовка пакета для передачи. Только в рабочем состоянии */
    __RW uint32_t TX_id2_rtr_dlc;                                               /**< Смещение: 0x2C Второй регистр заголовка пакета для передачи. Только в рабочем состоянии */
    __RW uint32_t TX_data_byte_1;                                               /**< Смещение: 0x30 Регистры содержимого пакета для передачи */
    __RW uint32_t TX_data_byte_2;                                               /**< Смещение: 0x34 Регистры содержимого пакета для передачи */
    __RW uint32_t TX_data_byte_3;                                               /**< Смещение: 0x38 Регистры содержимого пакета для передачи */
    __RW uint32_t TX_data_byte_4;                                               /**< Смещение: 0x3C Регистры содержимого пакета для передачи */
    __RW uint32_t TX_data_byte_5;                                               /**< Смещение: 0x40 Регистры содержимого пакета для передачи */
    __RW uint32_t TX_data_byte_6;                                               /**< Смещение: 0x44 Регистры содержимого пакета для передачи */
    __RW uint32_t TX_data_byte_7;                                               /**< Смещение: 0x48 Регистры содержимого пакета для передачи */
    __RW uint32_t TX_data_byte_8;                                               /**< Смещение: 0x4C Регистры содержимого пакета для передачи */
    __RO uint32_t RX_id1;                                                       /**< Смещение: 0x50 Первый регистр заголовка пакета для приема */
    __RO uint32_t RX_id2_rtr_dlc;                                               /**< Смещение: 0x54 Второй регистр заголовка пакета для приема */
    __RO uint32_t RX_data_byte_1;                                               /**< Смещение: 0x58 Регистры содержимого принимаемого пакета */
    __RO uint32_t RX_data_byte_2;                                               /**< Смещение: 0x5C Регистры содержимого принимаемого пакета */
    __RO uint32_t RX_data_byte_3;                                               /**< Смещение: 0x60 Регистры содержимого принимаемого пакета */
    __RO uint32_t RX_data_byte_4;                                               /**< Смещение: 0x64 Регистры содержимого принимаемого пакета */
    __RO uint32_t RX_data_byte_5;                                               /**< Смещение: 0x68 Регистры содержимого принимаемого пакета */
    __RO uint32_t RX_data_byte_6;                                               /**< Смещение: 0x6C Регистры содержимого принимаемого пакета */
    __RO uint32_t RX_data_byte_7;                                               /**< Смещение: 0x70 Регистры содержимого принимаемого пакета */
    __RO uint32_t RX_data_byte_8;                                               /**< Смещение: 0x74 Регистры содержимого принимаемого пакета */
    uint32_t reserved2;                                                         /**< Резерв*/
    __RW uint32_t Clock_divider;                                                /**< Смещение: 0x78 Регистр делителя рабочей частоты */
    
}CAN_T;

/**
 * @brief Макросы и типы для регистра CONTROL
 */
#define Reset_request(x)      ((uint32_t)((x) << 0))                              /**< Запись 1 в этот бит прерывает любую текущую передачу данных и переводит контоллер в состояние сброса. Запись 0 переводит контроллер в рабочее состояние. По умолчанию активно состояние сброса, бит имеет значение 1 */
#define Receive_Interrupt_Enable(x)      ((uint32_t)((x) << 1))                   /**< Включение прерывания приема. 1 - включено, 0 - отключено*/
#define Transmit_Interrupt_Enable(x)      ((uint32_t)((x) << 2))                  /**< Включение прерывания передачи. 1 - включено, 0 - отключено*/
#define Error_Interrupt_Enable(x)      ((uint32_t)((x) << 3))                     /**< Включение прерывания ошибки. 1 - включено, 0 - отключено*/
#define Overrun_Interrupt_Enable(x)      ((uint32_t)((x) << 4))                   /**< Включение прерывания переполнения. 1 - включено, 0 - отключено*/

/**
 * @brief Макросы и типы для регистра COMMAND
 */
#define Transmission_request(x)      ((uint32_t)((x) << 0))                       /**< Запись 1 запускает передачу сообщения в буфер для отправки (TX buffer)*/
#define Abort_transmission(x)      ((uint32_t)((x) << 1))                         /**< Запись 1 прерывает передачу, которая еще не была запущена*/
#define Release_receive_buffer(x)      ((uint32_t)((x) << 2))                     /**< Запись 1 очищает приемный буфер для новых данных*/
#define Clear_data_overrun(x)           ((uint32_t)((x) << 3))                    /**< Запись 1 очищает бит переполнения (Data overrun status) в регистре статуса*/

/**
 * @brief Макросы и типы для регистра STATUS
 */
#define Receive_buffer_status(x)           ((uint32_t)((x) << 0))                 /**< Значение 1 означает, что в приемном FIFO присутствуют принятые сообщения
                                                                                    Бит сбрасывается в 0, если была подана команда Release receive buffer через бит в регистре Command. Если при этом в приемном FIFO присутствуют последующие сообщения, бит будет установлен в 1 повторно.
                                                                                    */
#define Data_overrun_status(x)           ((uint32_t)((x) << 1))                   /**<Значение 1 означает, что сообщение было потеряно из-за отсутствия свободного места в FIFO
                                                                                    Бит означает, что полученное контроллером сообщение было утеряно, поскольку в приемном FIFO отсутствовало свободное место. Данный бит  устанавливается в момент вычитывания данных из FIFO.
                                                                                    */
#define Transmit_buffer_status(x)           ((uint32_t)((x) << 2))                /**<Значение 1 означает, что запись в передающий буфер разрешена
                                                                                Во время передачи сообщения передающий буфер запирается и бит имеет значение 0. Если контроллер не передает сообщения, бит имеет значение 1 и возможен запуск следующих сообщений на передачу.
                                                                                    */
#define Transmission_complete(x)           ((uint32_t)((x) << 3))                 /**< Значение 1 когда предыдущее сообщение было успешно передано
                                                                                    Бит сбрасывается в 0 сразу после начала передачи и не устанавливается в 1 до тех пор, пока сообщение не будет успешно передано.
                                                                                    */
#define Receive_status(x)           ((uint32_t)((x) << 4))                        /**< Значение 1 во время прием сообщения контроллером*/
#define Transmit_status(x)           ((uint32_t)((x) << 5))                        /**< Значение 1 во время прием сообщения контроллером*/
#define Error_Status(x)           ((uint32_t)((x) << 6))                          /**< Значение 1 когда хотя бы один из счетчиков ошибок превысил значение CPU warning limit = 96*/
#define Bus_status(x)           ((uint32_t)((x) << 7))                            /**< Значение 1 когда хотя бы один из счетчиков ошибок превысил значение CPU warning limit = 96*/

/**
 * @brief Макросы и типы для регистра INTERRUPT
 */
#define Receive_interrupt(x)           ((uint32_t)((x) << 0))                     /**< Устанавливается значение 1, если в приемном FIFO присутствуют принятые сообщения*/
#define Transmit_interrupt(x)           ((uint32_t)((x) << 1))                    /**< Устанавливается значение 1 в момент освобождения передающего буфера*/
#define Error_interrupt(x)           ((uint32_t)((x) << 2))                       /**<Устанавливается значение 1 если изменяется статус шины или статус ошибки*/
#define Data_overrun_interrupt(x)      ((uint32_t)((x) << 3))                     /**< Устанавливается в 1 когда бит Data overrun status в регистре Status переходит из 0 в 1*/


/**
 * @brief Структура для доступа к регистрам контроллера CAN в расширеном режим режиме.
 */
typedef struct
{
    __RW uint32_t Mode;                                                         /**< Смещение: 0x00 Регистр режима работы */
    __WO uint32_t COMMAND;                                                      /**< Смещение: 0x04 Регистр команд */
    __RO uint32_t STATUS;                                                       /**< Смещение: 0x08 Регистр статуса */
    __RO uint32_t INTERRUPT;                                                    /**< Смещение: 0x0C Регистр прерываний */
    __RW uint32_t Interrupt_enable;                                             /**< Смещение: 0x10 Регистр включения прерываний*/
    __RW uint32_t reserved;                                                     /**< Смещение: 0x14 */
    __RW uint32_t BUS_TIMING_0;                                                 /**< Смещение: 0x18 Первый регистр временных параметров шины. Только в состоянии сброса */
    __RW uint32_t BUS_TIMING_1;                                                 /**< Смещение: 0x1C Второй регистр временных параметров шины. Только в состоянии сброса */
    uint32_t reserved3[3];
    __RO uint32_t Arbitration_lost_capture;                                     /**< Смещение: 0x2C Регистр хранения позиции потери арбитрации*/
    __RO uint32_t Error_code_capture;                                           /**< Смещение: 0x30 Регистр кода ошибки */
    __RW uint32_t Error_warning_limit;                                          /**< Смещение: 0x34 Регистр максимального количества предупреждений. Доступен на запись только в состоянии сброса */
    __RW uint32_t RX_error_counter;                                             /**< Смещение: 0x38 Счетчик ошибок при приеме. Доступен на запись только в состоянии сброса */
    __RW uint32_t TX_error_counter;                                             /**< Смещение: 0x3C Счетчик ошибок при передаче. Доступен на запись только в состоянии сброса */
    
    /*В зависимости от состояния контроллера и формата сообщения данные регистры имеют различное назначение. 
    В состоянии сброса часть регистров задает приемный код и маску. 
    В рабочем состоянии при записи формируется содержимое сообщения для передачи, при чтении - вычитывается значение принятого сообщения. 
    Назначение регистров различно для стандартного (SFF) и расширенного (EFF) форматов сообщения.*/

    __RW uint32_t FI_SFF_FI_EFF_Acceptance_code_0;                              /**< Смещение: 0x40*/                                          
    __RW uint32_t ID_1_Acceptance_code_1;                                       /**< Смещение: 0x44*/                        
    __RW uint32_t ID_2_Acceptance_code_2;                                       /**< Смещение: 0x48*/ 
    __RW uint32_t Data1_ID_3_Acceptance_code_3;                                 /**< Смещение: 0x4С*/ 
    __RW uint32_t Data2_ID_4_Acceptance_mask_0;                                 /**< Смещение: 0x50*/               
    __RW uint32_t Data3_Data1_Acceptance_mask_1;                                /**< Смещение: 0x54*/               
    __RW uint32_t Data4_Data2_Acceptance_mask_2;                                /**< Смещение: 0x58*/               
    __RW uint32_t Data5_Data3_Acceptance_mask_3;                                /**< Смещение: 0x5С*/               
    __RW uint32_t Data6_Data4;                                                  /**< Смещение: 0x60*/   
    __RW uint32_t Data7_Data5;                                                  /**< Смещение: 0x64*/ 
    __RW uint32_t Data8_Data6;                                                  /**< Смещение: 0x68*/ 
    __RW uint32_t FIFO1_Data7;                                                  /**< Смещение: 0x6С*/ 
    __RW uint32_t FIFO2_Data8;                                                  /**< Смещение: 0x70*/ 
    __RO uint32_t RX_message_counter;                                           /**< Смещение: 0x74 Регистр счетчика принимаемых сообщений */
    uint32_t reserved2;                                                         /**< Резерв*/ 
    __RW uint32_t Clock_divider;                                                /**< Смещение: 0x7C Регистр делителя рабочей частоты */
    
}CAN_EXTANDED_T;

/**
 * @brief Макросы и типы для регистра Mode
 */
#define Reset_mode(x)      ((uint32_t)((x) << 0))                                 /**< Запись 1 в этот бит прерывает любую текущую передачу данных и переводит контоллер в состояние сброса. 
                                                                                Запись 0 переводит контроллер в рабочее состояние. По умолчанию активно состояние сброса, бит имеет значение 1*/
#define Listen_only_mode(x)      ((uint32_t)((x) << 1))                           /**< Запись 1 переводит контроллер в состояние прослушивания шины*/
#define Self_test_mode(x)      ((uint32_t)((x) << 2))                             /**< Запись 1 переводит контроллер в режим самодиагностики*/
#define Acceptance_filter_mode(x)      ((uint32_t)((x) << 3))                     /**< Значение 1 - режим одиночной фильтрации, 0 - режим двойной фильтрации*/

/**
 * @brief Макросы и типы для регистра CONTROL
 */
#define Transmission_request(x)      ((uint32_t)((x) << 0))                       /**< Запись 1 запускает передачу сообщения в буфер для отправки (TX buffer)*/
#define Abort_transmission(x)           ((uint32_t)((x) << 1))                    /**< Запись 1 прерывает передачу, которая еще не была запущена*/
#define Release_receive_buffer(x)      ((uint32_t)((x) << 2))                     /**< Запись 1 очищает приемный буфер для новых данных*/
#define Clear_data_overrun(x)      ((uint32_t)((x) << 3))                         /**< Запись 1 очищает бит переполнения (Data overrun status) в регистре статуса*/
#define Self_reception_request(x)      ((uint32_t)((x) << 4))                     /**< Запись 1 запускает передачу и одновременно прием сообщения*/

/*
 * @brief Макросы и типы для регистра STATUS
 */
// Регистр статуса в расширенном режиме идентичен по структуре регистру статуса в базовом режиме.

/**
 * @brief Макросы и типы для регистра INTERRUPT
 */
#define Receive_interrupt_ext(x)           ((uint32_t)((x) << 0))                 /**< Устанавливается значение 1, если в приемном FIFO присутствуют принятые сообщения*/
#define Transmit_interrupt_ext(x)           ((uint32_t)((x) << 1))                /**< Устанавливается значение 1 в момент освобождения передающего буфера*/
#define Error_warning_interrupt(x)           ((uint32_t)((x) << 2))               /**<Устанавливается значение 1 если изменяется статус шины или статус ошибки*/
#define Data_overrun_interrupt_ext(x)      ((uint32_t)((x) << 3))                 /**< Устанавливается в 1 когда бит Data overrun status в регистре Status переходит из 0 в 1*/
#define Error_passive_interrupt(x)      ((uint32_t)((x) << 5))                    /**< Устанавливается в 1 когда бит Data overrun status в регистре Status переходит из 0 в 1*/
#define Arbitration_lost_interrupt(x)      ((uint32_t)((x) << 6))                 /**< Устанавливается в 1 при потере арбитрации контроллером*/
#define Bus_error_interrupt(x)          ((uint32_t)((x) << 7))                    /**< Устанавливается в 1 если на шине обнаружена ошибка*/

/*
 * @brief Макросы и типы для регистра Interrupt_enable
 */
// Аналогичны битам для регистра INTERRUPT

/**
 * @brief Макросы и типы для регистра Arbitration_lost_capture
 */
#define Bit_number(x)           ((uint32_t)(((x)&0x1F) << 0))                     /**<Бит, в котором была потеряна арбитрация*/

/**
 * @brief Макросы и типы для регистра Error_code_capture
 */
#define Segment(x)           ((uint32_t)(((x)&0x1F) << 0))                     
/**<Местоположение ошибки внутри фрейма:
0x03 - Start of frame
0x02 - ID.28 - ID.21
0x06 - ID.20 - ID.18
0x04 - Bit SRTR
0x05 - Bit IDE
0x07 - ID.17 - ID.13
0x0F - ID.12 - ID.5
0x0E - ID.4 - ID.0
0x0C - Bit RTR
0x0D - Reserved bit 1
0x09 - Reserved bit 0
0x0B - Data length code
0x0A - Data field
0x08 - CRC sequence
0x18 - CRC delimiter
0x19 - Acknowledge slot
0x1B - Acknowledge delimiter
0x1A - End of frame
0x12 - Intermission
0x11 - Active error flag
0x16 - Passive error flag
0x13 - Tolerate dominant bits
0x17 - Error delimiter
0x1C - Overload flag4
*/
#define Direction(x)           ((uint32_t)((x) << 5))                           ///< Бит, в котором была потеряна арбитрация                  
#define Error_Code(x)           ((uint32_t)(((x)&0x3) << 6))                      
/**<Код ошибки:
0 - Bit error
1 - Form error
2 - Stuff error
3 - другое
*/            


/**
 * @brief Макросы и типы для регистра Clock_divider
 */
#define Clock_divisor(x)           ((uint32_t)(((x)&0x7) << 0))                   /**<Выбор частоты (не используется)*/
#define Clock_off(x)           ((uint32_t)((x) << 3))                           /**<Отключение вывода clkout*/
#define CAN_mode(x)           ((uint32_t)((x) << 7))                            /**<1 - расширенный режим, 0 - базовый режим*/

/**
 * @brief Макросы и типы для регистра Bus_timing_0
 */
#define BRP(x)           ((uint32_t)(((x)&0x3F) << 0))                            /**<Предделитель Baud rate*/
#define SJW(x)           ((uint32_t)(((x)&0x3) << 6))                             /**<Synchronization jump width*/

/**
 * @brief Макросы и типы для регистра Bus_timing_1
 */
#define TSEG1(x)           ((uint32_t)(((x)&0xF) << 0))                           /**<Time segment 1*/
#define TSEG2(x)           ((uint32_t)(((x)&0x3) << 4))                           /**<Time segment 2*/
#define SAM(x)                ((uint32_t)((x) << 7))                              /**<1 - шина сэмплируется 3 раза, 0 - единичное сэмплирование*/


#endif /* CAN_H */