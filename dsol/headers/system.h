/*!\file
 * \brief Этот файл содержит структуры, макросы и функции, необходимые для взаимодействия с регистрами общего назначения.
 *
 * Copyright(C) НПП Цифровые решения, 2018
 * Copyright(C) Команда разработчиков НПП Цифровые решения
 * Все права защищены.
 *
 * Программное обеспечение, описанное в этом файле, предназначено только для 
 * демонстрационных целей, и предоставляет программистам информацию о продукции 
 * организации "Цифровые решения". Это программное обеспечение поставляется "КАК ЕСТЬ" 
 * без каких-либо гарантий, "Цифровые решения" отказываются от любых гарантий, 
 * фактических или подразумеваемых, включая все подразумеваемые гарантии товарной пригодности, 
 * пригодности для конкретной цели и сохранения прав интеллектуальной собственности. 
 * Организация "Цифровые решения" не несет никакой ответственности за использование 
 * программного обеспечения, не предоставляет лицензий или прав на патент, авторское право, 
 * или любые другие права интеллектуальной собственности, на какие-либо продукты. 
 * Организация "Цифровые решения" оставляет за собой право вносить изменения в программное 
 * обеспечение без уведомления. Организация "Цифровые решения" также не дает никаких 
 * заверений или гарантий, что это программное приложение подойдет для использования 
 * без дальнейшего тестирования или модификаций.
 *
 * Разрешение на использование, копирование, изменение и распространение этого программного 
 * обеспечения и документации предоставляется согласно условиям "Цифровых решений" и 
 * соответствующих авторских прав своей лицензии без оплаты, при условии, 
 * что это программное обеспечение используется совместно с микроконтроллерами организации
 * "Цифровые решения". Эти права должны распространяться во всех копиях этого кода.
 */

#ifdef __cplusplus
extern "C"{
#endif

#ifndef SYSTEM_H_
#define SYSTEM_H_

#include "chip_5023BC016.h"
#include "types.h"



extern const uint32_t sys_freq; 
extern const uint32_t spw_freq;

#define CLK_INIT_PAUSE       for(int i=0; i<100000; i++)
#define CLK_FPU_PAUSE        for(int i=0; i<100; i++)
#define CLK_UART_PAUSE       for(int i=0; i<10000; i++)

/**
 *\brief Регистр мультиплексора прерываний
 */
typedef struct
{
    __RW uint32_t INTR_MUX_CTRL_Watchdog;                                       /**< Управляющий регистр, для WatchDog*/
    __RW uint32_t INTR_MUX_CTRL_Timer1;                                         /**< Управляющий регистр, для Timer1*/
    __RW uint32_t INTR_MUX_CTRL_Timer2;                                         /**< Управляющий регистр, для Timer2*/
    __RW uint32_t INTR_MUX_CTRL_Timer3;                                         /**< Управляющий регистр, для Timer3*/
    __RW uint32_t INTR_MUX_CTRL_Timer4;                                         /**< Управляющий регистр, для Timer4*/
    __RW uint32_t RESERVED[3];                                                  /**< Резерв */
    __RW uint32_t INTR_MUX_CTRL_GPIOA;                                          /**< Управляющий регистр, для GPIOA*/
    __RW uint32_t INTR_MUX_CTRL_GPIOB;                                          /**< Управляющий регистр, для GPIOB*/                                                  
    __RW uint32_t INTR_MUX_CTRL_GPIOC;                                          /**< Управляющий регистр, для GPIOC*/
    __RW uint32_t INTR_MUX_CTRL_GPIOD;                                          /**< Управляющий регистр, для GPIOD*/
    __RW uint32_t INTR_MUX_CTRL_GPIOE;                                          /**< Управляющий регистр, для GPIOE*/
    __RW uint32_t INTR_MUX_CTRL_GPIOF;                                          /**< Управляющий регистр, для GPIOF*/
    __RW uint32_t INTR_MUX_CTRL_GPIOG;                                          /**< Управляющий регистр, для GPIOG*/
    __RW uint32_t INTR_MUX_CTRL_GPIOH;                                          /**< Управляющий регистр, для GPIOH*/
    __RW uint32_t INTR_MUX_CTRL_GPIOI;                                          /**< Управляющий регистр, для GPIOI*/
    __RW uint32_t RESERVED1[7];                                                 /**< Резерв */
    __RW uint32_t INTR_MUX_CTRL_UART1;                                          /**< Управляющий регистр, для UART1*/
    __RW uint32_t INTR_MUX_CTRL_UART2;                                          /**< Управляющий регистр, для UART2*/
    __RW uint32_t INTR_MUX_CTRL_UART3;                                          /**< Управляющий регистр, для UART3*/
    __RW uint32_t INTR_MUX_CTRL_UART4;                                          /**< Управляющий регистр, для UART4*/
    __RW uint32_t INTR_MUX_CTRL_UART5;                                          /**< Управляющий регистр, для UART5*/
    __RW uint32_t INTR_MUX_CTRL_UART6;                                          /**< Управляющий регистр, для UART6*/
    __RW uint32_t RESERVED2[2];                                                 /**< Резерв */
    __RW uint32_t INTR_MUX_CTRL_SPI1;                                           /**< Управляющий регистр, для SPI1*/
    __RW uint32_t INTR_MUX_CTRL_SPI2;                                           /**< Управляющий регистр, для SPI2*/
    __RW uint32_t RESERVED3[2];                                                 /**< Резерв */
    __RW uint32_t INTR_MUX_CTRL_SPACEWIRE1;                                     /**< Управляющий регистр, для SPACEWIRE1*/
    __RW uint32_t INTR_MUX_CTRL_SPACEWIRE2;                                     /**< Управляющий регистр, для SPACEWIRE2*/
    __RW uint32_t RESERVED4[2];                                                 /**< Резерв */
    __RW uint32_t INTR_MUX_CTRL_MKPD1;                                          /**< Управляющий регистр, для MKPD1*/
    __RW uint32_t INTR_MUX_CTRL_MKPD2;                                          /**< Управляющий регистр, для MKPD2*/
    __RW uint32_t INTR_MUX_CTRL_MKPD3;                                          /**< Управляющий регистр, для MKPD3*/
    __RW uint32_t INTR_MUX_CTRL_MKPD4;                                          /**< Управляющий регистр, для MKPD4*/
    __RW uint32_t RESERVED5[4];                                                 /**< Резерв */
    __RW uint32_t INTR_MUX_CTRL_TMTX;                                           /**< Управляющий регистр, для TMTX*/
    __RW uint32_t INTR_MUX_CTRL_TCRX;                                           /**< Управляющий регистр, для TCRX*/
    __RW uint32_t INTR_MUX_CTRL_I2C;                                            /**< Управляющий регистр, для I2C*/
    __RW uint32_t RESERVED6[1];                                                 /**< Резерв */
    __RW uint32_t INTR_MUX_CTRL_CAN1;                                           /**< Управляющий регистр, для CAN1*/
    __RW uint32_t INTR_MUX_CTRL_CAN2;                                           /**< Управляющий регистр, для CAN2*/
    __RW uint32_t RESERVED7[2];                                                 /**< Резерв */
    __RW uint32_t INTR_MUX_CTRL_EDAC;                                           /**< Управляющий регистр, для EDAC*/
    __RW uint32_t RESERVED8[3];                                                 /**< Резерв */
    __RW uint32_t INTR_MUX_CTRL_RES_Q;                                          /**< Резерв*/
    __RW uint32_t RESERVED9[3];                                                 /**< Резерв */
    __RW uint32_t INTR_MUX_CTRL_RES_P1;                                         /**< Резерв*/
    __RW uint32_t INTR_MUX_CTRL_RES_P2;                                         /**< Резерв*/
    __RW uint32_t INTR_MUX_CTRL_RES_P3;                                         /**< Резерв*/
    __RW uint32_t INTR_MUX_CTRL_RES_P4;                                         /**< Резерв*/
    __RW uint32_t RESERVED10[28];                                               /**< Резерв */
    __RW uint32_t INTR_MUX_CTRL_DMASPI1_TX;                                     /**< Управляющий регистр, для DMASPI1_TX*/
    __RW uint32_t INTR_MUX_CTRL_DMASPI1_RX;                                     /**< Управляющий регистр, для DMASPI1_RX*/
    __RW uint32_t INTR_MUX_CTRL_DMASPI2_TX;                                     /**< Управляющий регистр, для DMASPI2_TX*/
    __RW uint32_t INTR_MUX_CTRL_DMASPI2_RX;                                     /**< Управляющий регистр, для DMASPI2_RX*/
    __RW uint32_t INTR_MUX_CTRL_DMAUART1_TX;                                    /**< Управляющий регистр, для DMAUART1_TX*/
    __RW uint32_t INTR_MUX_CTRL_DMAUART1_RX;                                    /**< Управляющий регистр, для DMAUART1_RX*/
    __RW uint32_t INTR_MUX_CTRL_DMAUART2_TX;                                    /**< Управляющий регистр, для DMAUART2_TX*/
    __RW uint32_t INTR_MUX_CTRL_DMAUART2_RX;                                    /**< Управляющий регистр, для DMAUART2_RX*/
    __RW uint32_t INTR_MUX_CTRL_DMAUART3_TX;                                    /**< Управляющий регистр, для DMAUART3_TX*/
    __RW uint32_t INTR_MUX_CTRL_DMAUART3_RX;                                    /**< Управляющий регистр, для DMAUART3_RX*/
    __RW uint32_t INTR_MUX_CTRL_DMAUART4_TX;                                    /**< Управляющий регистр, для DMAUART4_TX*/
    __RW uint32_t INTR_MUX_CTRL_DMAUART4_RX;                                    /**< Управляющий регистр, для DMAUART4_RX*/
    __RW uint32_t INTR_MUX_CTRL_DMAUART5_TX;                                    /**< Управляющий регистр, для DMAUART5_TX*/
    __RW uint32_t INTR_MUX_CTRL_DMAUART5_RX;                                    /**< Управляющий регистр, для DMAUART5_RX*/
    __RW uint32_t INTR_MUX_CTRL_DMAUART6_TX;                                    /**< Управляющий регистр, для DMAUART6_TX*/
    __RW uint32_t INTR_MUX_CTRL_DMAUART6_RX;                                    /**< Управляющий регистр, для DMAUART6_RX*/
    __RW uint32_t INTR_MUX_CTRL_DMA_CHAN16;                                     /**< Управляющий регистр, для DMA_CHAN16*/
    __RW uint32_t INTR_MUX_CTRL_DMA_CHAN17;                                     /**< Управляющий регистр, для DMA_CHAN17*/
    __RW uint32_t INTR_MUX_CTRL_DMA_CHAN18;                                     /**< Управляющий регистр, для DMA_CHAN18*/
    __RW uint32_t INTR_MUX_CTRL_DMA_CHAN19;                                     /**< Управляющий регистр, для DMA_CHAN19*/
    __RW uint32_t INTR_MUX_CTRL_DMA_CHAN20;                                     /**< Управляющий регистр, для DMA_CHAN20*/
    __RW uint32_t INTR_MUX_CTRL_DMA_CHAN21;                                     /**< Управляющий регистр, для DMA_CHAN21*/
    __RW uint32_t INTR_MUX_CTRL_DMA_CHAN22;                                     /**< Управляющий регистр, для DMA_CHAN22*/
    __RW uint32_t INTR_MUX_CTRL_DMA_CHAN23;                                     /**< Управляющий регистр, для DMA_CHAN23*/
}CONTROL_MUX_REGISTER;

/**
 * @brief Макросы для INTR_MUX_CTRL
 */
#define INTR_SRC_ENABLE                 ((uint32_t)(1<<31))                     /**< 1 – включение источника прерывания */
#define NUM_INTR_VECTOR(x)              ((uint32_t)(((x)&0x1F)<<0))               /**< номер вектора прерываний от 0 до 31, на который направляется соответствующий источник прерываний*/   


/** \brief  Номера прерываний в регистрах NVIC
 */
typedef enum 
{
    Watchdog             = 0,                                                   /**< номер прерывания Watchdog */
    Timer1               = 1,                                                   /**< номер прерывания Timer1 */
    Timer2               = 2,                                                   /**< номер прерывания Timer2*/
    Timer3               = 3,                                                   /**< номер прерывания Timer3 */
    Timer4               = 4,                                                   /**< номер прерывания Timer4*/
    GPIOA                = 8,                                                   /**< номер прерывания GPIO A */
    GPIOB                = 9,                                                   /**< номер прерывания GPIO B */
    GPIOC                = 10,                                                  /**< номер прерывания GPIO C */
    GPIOD                = 11,                                                  /**< номер прерывания GPIO D */
    GPIOE                = 12,                                                  /**< номер прерывания GPIO E */
    GPIOF                = 13,                                                  /**< номер прерывания GPIO F */
    GPIOG                = 14,                                                  /**< номер прерывания GPIO G */
    GPIOH                = 15,                                                  /**< номер прерывания GPIO H */
    GPIOI                = 16,                                                  /**< номер прерывания GPIO I */
    UART_1               = 24,                                                  /**< номер прерывания UART1 */ 
    UART_2               = 25,                                                  /**< номер прерывания UART2 */ 
    UART_3               = 26,                                                  /**< номер прерывания UART3*/
    UART_4               = 27,                                                  /**< номер прерывания UART4 */
    UART_5               = 28,                                                  /**< номер прерывания UART5 */
    UART_6               = 29,                                                  /**< номер прерывания UART6 */ 
    SPI_1                = 32,                                                  /**< номер прерывания SPI 1 */ 
    SPI_2                = 33,                                                  /**< номер прерывания SPI 2 */ 
    Spacewire1           = 36,                                                  /**< номер прерывания Spacewire1 */ 
    Spacewire2           = 37,                                                  /**< номер прерывания Spacewire2 */ 
    MKPD1_NUM            = 40,                                                  /**< номер прерывания MKPD1 */ 
    MKPD2_NUM            = 41,                                                  /**< номер прерывания MKPD2 */ 
    MKPD3_NUM            = 42,                                                  /**< номер прерывания MKPD3 */ 
    MKPD4_NUM            = 43,                                                  /**< номер прерывания MKPD4 */ 
    TMTX_NUM             = 48,                                                  /**< номер прерывания TMTX */ 
    TCRX_NUM             = 49,                                                  /**< номер прерывания TCRX */ 
    I2C_NUM              = 50,                                                  /**< номер прерывания I2C */ 
    CAN1_NUM             = 52,                                                  /**< номер прерывания CAN1 */ 
    CAN2_NUM             = 53,                                                  /**< номер прерывания CAN2 */ 
    EDAC                 = 56,                                                  /**< номер прерывания EDAC */ 
    RES_Q_NUM            = 60,                                                  /**< Резерв */ 
    RESERVE_P1_NUM       = 64,                                                  /**< Резерв */ 
    RESERVE_P2_NUM       = 65,                                                  /**< Резерв*/ 
    RESERVE_P3_NUM       = 66,                                                  /**< Резерв */ 
    RESERVE_P4_NUM       = 67,                                                  /**< Резерв */ 
    DMA_SPI_1_TX         = 96,                                                  /**< номер прерывания DMA_SPI_1_TX */ 
    DMA_SPI_1_RX         = 97,                                                  /**< номер прерывания DMA_SPI_1_TX */ 
    DMA_SPI_2_TX         = 98,                                                  /**< номер прерывания DMA_SPI_2_TX */ 
    DMA_SPI_2_RX         = 99,                                                  /**< номер прерывания DMA_SPI_2_RX */ 
    DMA_UART_1_TX        = 100,                                                 /**< номер прерывания DMA_UART_1_TX */ 
    DMA_UART_1_RX        = 101,                                                 /**< номер прерывания DMA_UART_1_RX */ 
    DMA_UART_2_TX        = 102,                                                 /**< номер прерывания DMA_UART_2_TX */ 
    DMA_UART_2_RX        = 103,                                                 /**< номер прерывания DMA_UART_2_RX */ 
    DMA_UART_3_TX        = 104,                                                 /**< номер прерывания DMA_UART_3_TX */ 
    DMA_UART_3_RX        = 105,                                                 /**< номер прерывания DMA_UART_3_RX */ 
    DMA_UART_4_TX        = 106,                                                 /**< номер прерывания DMA_UART_4_TX */ 
    DMA_UART_4_RX        = 107,                                                 /**< номер прерывания DMA_UART_4_RX */ 
    DMA_UART_5_TX        = 108,                                                 /**< номер прерывания DMA_UART_5_TX */ 
    DMA_UART_5_RX        = 109,                                                 /**< номер прерывания DMA_UART_5_RX */ 
    DMA_UART_6_TX        = 110,                                                 /**< номер прерывания DMA_UART_6_TX */ 
    DMA_UART_6_RX        = 111,                                                 /**< номер прерывания DMA_UART_6_RX */                    
    DMA_CHAN16           = 112,                                                 /**< номер прерывания DMA_CHAN16 */
    DMA_CHAN17           = 113,                                                 /**< номер прерывания DMA_CHAN17 */
    DMA_CHAN18           = 114,                                                 /**< номер прерывания DMA_CHAN18 */
    DMA_CHAN19           = 115,                                                 /**< номер прерывания DMA_CHAN19 */
    DMA_CHAN20           = 116,                                                 /**< номер прерывания DMA_CHAN20 */
    DMA_CHAN21           = 117,                                                 /**< номер прерывания DMA_CHAN21 */
    DMA_CHAN22           = 118,                                                 /**< номер прерывания DMA_CHAN22 */
    DMA_CHAN23           = 119,                                                 /**< номер прерывания DMA_CHAN23 */
} IRQn_T;

/** \brief  Структура для доступа к регистрам общего назначения
 */
typedef struct 
{
    __RW uint32_t EXTMEM_CTRL;                                                  /**< Смещение: 0x000 Конфигурирование контроллера внешней памяти */
    __RW uint32_t EDAC_CTRL;                                                    /**< Смещение: 0x004 Включение режима обнаружения и исправления ошибок внутренней памяти */
    __RO  uint32_t INTMEM_CERR_CNT;                                             /**< Смещение: 0x008 Счетчик исправленных ошибок внутренней памяти */
    __RO  uint32_t INTMEM_FERR_CNT;                                             /**< Смещение: 0x00C Счетчик неисправимых ошибок внутренней памяти */
    __RO  uint32_t EXTMEM_CERR_CNT;                                             /**< Смещение: 0x010 Счетчик исправленных ошибок внешней памяти */
    __RO  uint32_t EXTMEM_FERR_CNT;                                             /**< Смещение: 0x014 Счетчик неисправимых ошибок внешней памяти */
       uint32_t RESERVED;
    __RW uint32_t SPACEWIRE_CLK_CTRL;                                           /**< Смещение: 0x01C Выбор тактовой частоты блоков Spacewire */
    __RO uint32_t INTMEM2_CERR_CNT;                                             /**< Смещение: 0x020 Счетчик исправленных ошибок внутренней памяти блока 2*/
    __RO uint32_t INTMEM2_FERR_CNT;                                             /**< Смещение: 0x024 Счетчик неисправимых ошибок внутренней памяти блока 2*/
    __RW uint32_t PWR_CTRL_CLK;                                                 /**< Смещение: 0x028 Включение тактовых частот различных блоков */
    __RW uint32_t PWR_CTRL_RST;                                                 /**< Смещение: 0x02C Асинхронный сброс различных блоков*/
    __RW uint32_t EXTMEM2_CTRL;                                                 /**< Смещение: 0x030 Конфигурирование контроллера внешней памяти по Chip Select 2*/
    __RW uint32_t EXTMEM3_CTRL;                                                 /**< Смещение: 0x034 Конфигурирование контроллера внешней памяти по Chip Select 3*/
    __RW uint32_t EXTMEM4_CTRL;                                                 /**< Смещение: 0x038 Конфигурирование контроллера внешней памяти по Chip Select 4*/
    __RW uint32_t CACHE_HIGH_ADDR;                                              /**< Смещение: 0x3C Задает пространство работы кэша*/
    __RW uint32_t INTMEM_SCR_RNG_ADDR;                                          /**< Смещение: 0x40 Диапазон адресов скраббера для блока памяти 1*/
    __RW uint32_t INTMEM_SCR_PRD_SCAN;                                          /**< Смещение: 0x44 Период сканирования скраббера для блока памяти 1*/
    __RW uint32_t INTMEM_SCR_PRD_STOP;                                          /**< Смещение: 0x48 Период прерывания скраббером контроллер памяти 1*/
    __RW uint32_t INTMEM2_SCR_RNG_ADDR;                                         /**< Смещение: 0x4С Диапазон адресов скраббера для блока памяти 2.*/
    __RW uint32_t INTMEM2_SCR_PRD_SCAN;                                         /**< Смещение: 0x50 Период сканирования скраббера для блока памяти 2*/
    __RW uint32_t INTMEM2_SCR_PRD_STOP;                                         /**< Смещение: 0x54 Период прерывания скраббером контроллер памяти 2*/
    __RW uint32_t INTMEMS_SCR_MAIN;                                             /**< Смещение: 0x58 Общее управление скрабберами*/
    __RW uint32_t CACHE_CRC_ERROR;                                              /**< Смещение: 0x5С Счетчик crc ошибок в кэше*/  
    __RW uint32_t EDAC_INTMEM_SCR_CERR;                                         /**< Смещение: 0x60 Счетчик исправимых ошибок, обнаруженных скраббером блока памяти 1*/
    __RW uint32_t EDAC_INTMEM_SCR_FERR;                                         /**< Смещение: 0x64 Счетчик неисправимых ошибок, обнаруженных скраббером блока памяти 1*/
    __RW uint32_t EDAC_INTMEM2_SCR_CERR;                                        /**< Смещение: 0x68 Счетчик исправимых ошибок, обнаруженных скраббером блока памяти 2*/  
    __RW uint32_t EDAC_INTMEM2_SCR_FERR;                                        /**< Смещение: 0x6С Счетчик неисправимых ошибок, обнаруженных скраббером блока памяти 2*/ 
    __RW uint32_t DMA_INTR_FLAGS;                                               /**< Смещение: 0x70 Флаги прерываний DMA*/ 
    __RW uint32_t ALT_FUNCTION_CTRL[9];                                         /**< Смещение: 0x74-0x94 Выбор альтернативной функции для каждого порта GPIO*/ 
    __RW uint32_t RESERVED_1[2];                                                /**< Резерв */
    __RW uint32_t CACHE_HIGH_ADDR_CS2;                                          /**< Смещение: 0xA0 Задает пространство работы кэша для памяти по Chip Select 2*/ 
    __RW uint32_t CACHE_HIGH_ADDR_CS3;                                          /**< Смещение: 0xА4 Задает пространство работы кэша для памяти по Chip Select 3*/
    __RW uint32_t CACHE_HIGH_ADDR_CS4;                                          /**< Смещение: 0xА8 Задает пространство работы кэша для памяти по Chip Select 4*/
    __RW uint32_t ALIAS_CTRL;                                                   /**< Смещение: 0xАС Настройка алиасинга для области адресов 0x0000_0000-0x00FF_FFFF*/
    __RO uint32_t SCRUBBER_FERR_ADDR;                                           /**< Смещение: 0xВ0 Адрес последнего FERR для скрабберов*/
    __RO uint32_t COMMON_FERR_ADDR;                                             /**< Смещение: 0xВ4 Адрес последнего FERR для внешней и внутренней памяти без скраббера.*/
    __RW uint32_t EDAC_REACTION_CTRL;                                           /**< Смещение: 0xВ8 Управление реакцией на ошибки EDAC и CRC*/
    __RW uint32_t GLOBAL_RESET;                                                 /**< Смещение: 0xВC Сброс всех блоков, включая отладчик (W1O)*/
    __RW uint32_t RES_P_SYNC;                                                   /**< Резерв*/
    __RW uint32_t CACHE_MAIN;                                                   /**< Смещение: 0xC4 Включение / сброс и статус кэша*/  
}CMN_REG_T;

/**
 * @brief Макросы для регистра EXTMEM_CTRL
 */
#define EXT_MEM_READ_CYCLES(x)                  ((uint32_t)(((x) & 0x7) << 0))  /**< количество системных тактов, за время которых происходит операция чтения из внешней памяти */ 
#define EXT_MEM_WRITE_CYCLES(x)                 ((uint32_t)(((x) & 0x7) << 3))  /**< количество системных тактов, за время которых происходит операция записи во внешнюю память */ 
#define EXT_MEM_TURN_CYCLES(x)                  ((uint32_t)(((x) & 0x7) << 6))  /**< пауза в системных тактах, между операцией чтения и записи, и наоборот */ 
//#define EXT_MEM_SIZE                            ((uint32_t)(1 << 16))           /**< Выбор режима разрядности внешней памяти по Chip Select 1. Значение 0 – 8-битная шина данных, 
                                                                                   // значение 1 – 16-битная шина данных. Имеет значение, только если бит SIZE_FORCE выставлен в 1*/
#define EXT_MEM_SIZE(x)                         ((uint32_t)(((x) & 0x1) << 16))   /**< Выбор режима разрядности внешней памяти по Chip Select 1. Значение 0 – 8-битная шина данных, 
                                                                                   // значение 1 – 16-битная шина данных. Имеет значение, только если бит SIZE_FORCE выставлен в 1*/
#define EXT_MEM_EDAC                            ((uint32_t)(1 << 24))           /**< Включение блока исправления ошибок внешней памяти по Chip Select 1.
                                                                                    Значение 0 – блок исправления ошибок не используется, 
                                                                                1 – блок исправления ошибок включен. Имеет значение, только если бит EDAC_FORCE выставлен в 1*/
#define EXT_MEM_SIZE_FORCE                      ((uint32_t)(1 << 30))           /**< Если поле имеет значение 1, разрядность шины данных внешней памяти по Chip Select 1 определяется полем Size, 
                                                                                    иначе определяется значением внешнего вывода EXTMEM_CFGSIZE*/
#define EXT_MEM_EDAC_FORCE                      ((uint32_t)(1 << 31))           /**< Если поле имеет значение 1, использование блока исправления ошибок по Chip Select 1 определяется полем EDAC, 
                                                                                    иначе определяется значением внешнего вывода EXTMEM_EDAC_EN*/

/**
 * @brief Макросы для регистра EDAC_CTRL
 */
#define EDAC_En_1                               ((uint32_t)(1 << 0))            /**< Включение режима исправления единичных и обнаружения неисправимых ошибок во внутренней памяти блока 1.*/
#define EDAC_En_2                               ((uint32_t)(1 << 1))            /**< Включение режима исправления единичных и обнаружения неисправимых ошибок во внутренней памяти блока 2 */
#define EDAC_WR_DIS_1                           ((uint32_t)(1 << 2))            /**< Отключение записи битов EDAC для блока памяти 1 */
#define EDAC_WR_DIS_2                           ((uint32_t)(1 << 3))            /**< Отключение записи битов EDAC для блока памяти 2 */

/**
 * @brief Макросы для регистра INTMEM_CERR_CNT
 */
#define INTMEM_CERR_CNT(x)                   ((uint32_t)(((x)&0xFFFFFFFF) << 0))  /**< Счетчик исправленных единичных ошибок внутренней памяти блока 1.*/

/**
 * @brief Макросы для регистра INTMEM_FERR_CNT
 */
#define INTMEM_FERR_CNT(x)                   ((uint32_t)(((x)&0xFFFFFFFF) << 0))  /**< Счетчик неисправимых ошибок внутренней памяти блока 1.*/

/**
 * @brief Макросы для регистра EXTMEM_CERR_CNT
 */
#define EXTMEM_CERR_CNT(x)                   ((uint32_t)(((x)&0xFFFFFFFF) << 0))  /**< Счетчик исправленных единичных ошибок внешней памяти*/

/**
 * @brief Макросы для регистра EXTMEM_FERR_CNT
 */
#define EXTMEM_FERR_CNT(x)                   ((uint32_t)(((x)&0xFFFFFFFF) << 0))  /**< Счетчик неисправимых ошибок внешней памяти*/

/**
 * @brief Макросы для регистра SPACEWIRE_CLK_CTRL
 */
#define SPACEWIRE_CLK_CTRL(x)                      ((uint32_t)((x) << 16))           /**< выбор тактовой частоты физического уровня блоков Spacewire.
                                                                                    0 – тактирование осуществляется с внешнего вывода SW_CLK (PORTH[4]).
                                                                                    1 – тактирование осуществляется системной частотой  
                                                                                */
/**
 * @brief Макросы для регистра INTMEM2_CERR_CNT
 */
#define NTMEM2_CERR_CNT(x)                   ((uint32_t)(((x)&0xFFFFFFFF) << 0))  /**< Счетчик исправленных единичных ошибок внутренней памяти блока 2*/

/**
 * @brief Макросы для регистра INTMEM2_FERR_CNT
 */
#define INTMEM2_FERR_CNT(x)                   ((uint32_t)(((x)&0xFFFFFFFF) << 0)) /**< Счетчик неисправимых ошибок внутренней памяти блока 2.*/

/**
 * @brief Макросы для регистра PWR_CTRL_CLK
 *Расшифровка битовых полей для регистров PWR_CTRL_CLK и PWR_CTRL_RST,
 *каждый бит соответствует включению одного модуля:
 *0 – SPI_1	13 – Telecommand Decoder (TCRX)
 *1 – SPI_2	14 – FPU
 *2 – UART_1	
 *3 – UART_2	
 *4 — UART_3	
 *5 — UART_4	
 *6 – Spacewire_1	
 *7 – Spacewire_2	20 — CAN_1
 *8 – MKPD1	21 — CAN_2
 *9 – MKPD2	22 — UART_5
 *10 – MKPD3	23 — UART_6
 *11 – MKPD4	24 — I2C
 *12 – Telemetry Encoder (TMTX)	25-31 – не используются
 *
 */
#define PWR_CTRL_CLK(x)                   ((uint32_t)(((x)&0xFFFFFFFF) << 0))     /**< Включение тактовых частот для различных блоков. (1 – вкл).*/

/**
 * @brief Макросы для регистра PWR_CTRL_RST
 *Расшифровка битовых полей для регистров PWR_CTRL_CLK и PWR_CTRL_RST, каждый бит соответствует включению одного модуля:
 *0 – SPI_1	13 – Telecommand Decoder (TCRX)
 *1 – SPI_2	14 – FPU
 *2 – UART_1	
 *3 – UART_2	
 *4 — UART_3	
 *5 — UART_4	
 *6 – Spacewire_1	
 *7 – Spacewire_2	20 — CAN_1
 *8 – MKPD1	21 — CAN_2
 *9 – MKPD2	22 — UART_5
 *10 – MKPD3	23 — UART_6
 *11 – MKPD4	24 — I2C
 *12 – Telemetry Encoder (TMTX)	25-31 – не используются
 *
 */
#define PWR_CTRL_RST(x)                   ((uint32_t)(((x)&0xFFFFFFFF) << 0))     /**< Включение путем вывода из асинхронного сброса для различных блоков. (1 – вкл)*/

/**
 * @brief Макросы для регистра EXTMEM_CTRL(Chip Select 2-4) 
 */
#define EXT_MEM_READ_CYCLES_2_4(x)              ((uint32_t)(((x) & 0x7) << 0))  /**< количество системных тактов, за время которых происходит операция чтения из внешней памяти. 
                                                                                    Значение 0 – 1 такт, значение 1 - 2 такта,... значение 7 - 8 тактов */ 
#define EXT_MEM_WRITE_CYCLES_2_4(x)             ((uint32_t)(((x) & 0x7) << 3))  /**< количество системных тактов, за время которых происходит операция записи во внешнюю память. 
                                                                                    Значение 0 – 1 такт, значение 1 - 2 такта,... значение 7 - 8 тактов*/ 
#define EXT_MEM_TURN_CYCLES_2_4(x)              ((uint32_t)(((x) & 0x7) << 6))  /**< Turn_cycles 	величина задержки Chip Select (сигнал CEN) в тактах системной частоты, которая приводит к паузе перед каждой операцией записи или чтения. 
                                                                                     Значение 0 – нет задержки, значение 1 - 1 такт задержки,... значение 7 - 7 тактов задержки */ 
#define EXT_MEM_SIZE_2_4                        ((uint32_t)(1 << 16))           /**< 0 - 8-битный режим; 1 - 16-битный режим*/
#define EXT_MEM_EDAC_2_4                        ((uint32_t)(1 << 24))           /**< для внешней памяти 0 - выключен; 1 — включен*/


/**
 * @brief Макросы для регистра CACHE_HIGH_ADDR
 */
#define CACHE_HIGH_ADDR(x)                   ((uint32_t)(((x)&0x7FFFFF) << 2))   /**< задает старший адрес в памяти, используемый блоком кэширования. Кэшироваться будут данные, 
                                                                                     расположенные по адресам между 0 и указанным значением не включительно. 
                                                                                     При увеличении значения этого поля, происходит переинициализация блока кэширования, 
                                                                                     при уменьшении значения поля переинициализация не происходит*/

/**
 * @brief Макросы для регистра CACHE_HIGH_ADDR_CS2
 */
#define CACHE_HIGH_ADDR_CS2(x)                ((uint32_t)(((x)&0x7FFFFF) << 2))   /**< задает старший адрес в памяти, используемый блоком кэширования. Кэшироваться будут данные, 
                                                                                     расположенные по адресам между 0 и указанным значением не включительно. 
                                                                                     При увеличении значения этого поля, происходит переинициализация блока кэширования, 
                                                                                     при уменьшении значения поля переинициализация не происходит*/

/**
 * @brief Макросы для регистра CACHE_HIGH_ADDR_CS3
 */
#define CACHE_HIGH_ADDR_CS3(x)                ((uint32_t)(((x)&0x7FFFFF) << 2))   /**< задает старший адрес в памяти, используемый блоком кэширования. Кэшироваться будут данные, 
                                                                                     расположенные по адресам между 0 и указанным значением не включительно. 
                                                                                     При увеличении значения этого поля, происходит переинициализация блока кэширования, 
                                                                                     при уменьшении значения поля переинициализация не происходит*/

/**
 * @brief Макросы для регистра CACHE_HIGH_ADDR_CS4
 */
#define CACHE_HIGH_ADDR_CS4(x)                ((uint32_t)(((x)&0x7FFFFF) << 3))   /**< задает старший адрес в памяти, используемый блоком кэширования. Кэшироваться будут данные, 
                                                                                     расположенные по адресам между 0 и указанным значением не включительно. 
                                                                                     При увеличении значения этого поля, происходит переинициализация блока кэширования, 
                                                                                     при уменьшении значения поля переинициализация не происходит*/

/**
 * @brief Макросы для регистра INTMEM_SCR_RNG_ADDR
 */
#define INTMEM_SCR_RNG_ADDR(x)                ((uint32_t)(((x)&0x1FFF) << 3))     /**< задает верхнюю границу работы скраббера внутри блока памяти*/

/**
 * @brief Макросы для регистра INTMEM2_SCR_RNG_ADDR
 */
#define INTMEM2_SCR_RNG_ADDR(x)                ((uint32_t)(((x)&0x1FFF) << 3))    /**< задает верхнюю границу работы скраббера внутри блока памяти*/

/**
 * @brief Макросы для регистра INTMEM_SCR_PRD_SCAN
 */
#define INTMEM_SCR_PRD_SCAN(x)             ((uint32_t)(((x)&0xFFFFFFFF) << 0))    /**< период сканирования заданной области скраббером в тактах.0 - сканирует постоянно.*/

/**
 * @brief Макросы для регистра INTMEM2_SCR_PRD_SCAN
 */
#define INTMEM2_SCR_PRD_SCAN(x)            ((uint32_t)(((x)&0xFFFFFFFF) << 0))    /**< период сканирования заданной области скраббером в тактах.0 - сканирует постоянно.*/

/**
 * @brief Макросы для регистра INTMEM_SCR_PRD_STOP
 */
#define INTMEM_SCR_PRD_STOP(x)            ((uint32_t)(((x)&0xFFFFFFFF) << 0))     /**< период прерывания скраббером контроллера памяти, если в контроллере нет пустых транзакций 
                                                                                    к соответствующему чипу памяти.0 - прерывает сразу.*/
/**
 * @brief Макросы для регистра INTMEM2_SCR_PRD_STOP
 */
#define INTMEM2_SCR_PRD_STOP(x)            ((uint32_t)(((x)&0xFFFFFFFF) << 0))    /**< период прерывания скраббером контроллера памяти, если в контроллере нет пустых транзакций 
                                                                                    к соответствующему чипу памяти.0 - прерывает сразу.*/
/**
 * @brief Макросы для регистра INTMEMS_SCR_MAIN
 */
#define SCRUB_BLK1_EN                          ((uint32_t)((1<< 0))             /**< RW*/
#define SCRUB_BLK2_EN                          ((uint32_t)((1<< 1))             /**< 1 - включает скраббер для соответствуещего блока памяти*/
#define SCRUB_BLK1_READY                       ((uint32_t)((1<< 2))             /**< 1 - сообщает о готовности всех скрабберов для соответствующего блока памяти*/
#define SCRUB_BLK2_READY                       ((uint32_t)((1<< 2))             /**< 1 - сообщает о готовности всех скрабберов для соответствующего блока памяти*/
#define SCRUB_BLK1_CS_READY(x)                 ((uint32_t)(((x)&0xF) << 4))       /**< отдельные биты готовности скрабберов по каждому Chip Select (четные и нечетные)*/
#define SCRUB_BLK2_CS_READY(x)                 ((uint32_t)(((x)&0xF) << 8))       /**< отдельные биты готовности скрабберов по каждому Chip Select (четные и нечетные)*/

/**
 * @brief Макросы для регистра DMA_INTR_FLAGS
 *
 * [15:0] флаги прерываний DMA, сбрасываются записью 1.
 * [0] –  SSP1 TX 
 * [1] –  SSP1 RX
 * [2] –  SSP2 TX 
 * [3] –  SSP2 RX
 * [4] –  UART1 TX
 * [5] –  UART1 RX
 * [6] –  UART2 TX
 * [7] –  UART2 RX
 * [8] –  UART3 TX
 * [9] –  UART3 RX
 * [10] –  UART4 TX
 * [11] –  UART4 RX
 * [12] –  UART5 TX
 * [13] –  UART5 RX
 * [14] –  UART6 TX
 * [15] –  UART6 RX
 */
#define DMA_INTR_FLAGS(x)                  ((uint32_t)(((x)&0xFF) << 0))    /**< Флаги прерываний*/

/**
 * @brief Макросы для регистра ALT_FUNC_CONTROL
 */
#define BIT_FUNC(x)                      ((uint32_t)(((x)&0xFFFFFFFF) << 0))      /**< период сканирования заданной области скраббером в тактах.0 - сканирует постоянно.*/

/**
 * @brief Макросы для регистра ALIAS_CTRL
 */
#define INTMEM_ALIAS(x)                 ((uint32_t)(((x)&0x3) << 0))              /**< алиасинг для внутренней памяти:
                                                                                    0 — нет алиасинга;
                                                                                    1 — алиасинг только блока 1 (0x2000_0000 — 0x2000_FFFF); 
                                                                                    2 — алиасинг только блока 2 (0x2001_0000 — 0x2001_FFFF); 
                                                                                    3 — алиасинг обоих блоков  (0x2000_0000 — 0x2001_FFFF). 
                                                                                    .*/
#define EXTMEM_ALIAS(x)                 ((uint32_t)(((x)&0x3) << 2))              /**< алиасинг для внешней памяти имеет значение только если INTMEM_ALIAS=0:
                                                                                    0 — алиасинг внешней памяти по Chip Select 1 
                                                                                    (0x0800_0000 — 0x08FF_FFFF);
                                                                                    1 — алиасинг внешней памяти по Chip Select 2 
                                                                                    (0x0900_0000 — 0x09FF_FFFF);
                                                                                    2 — алиасинг внешней памяти по Chip Select 3 
                                                                                    (0x0A00_0000 — 0x0AFF_FFFF);
                                                                                    3 — алиасинг внешней памяти по Chip Select 4 
                                                                                    (0x0B00_0000 — 0x0BFF_FFFF).
                                                                                    */      
/**
 * @brief Макросы для регистра EDAC_REACTION_CTRL
 *
 *Реакции на соответствующие события:
 *0 — нет реакции;
 *1 — прерывание;
 *2 — исключение;
 *3 — сброс всего, исключая дебаг;
 *4 — сброс всего, включая дебаг;
 *6-7 — нет реакции.
 *
 */
#define EXTMEM_CERR(x)                 ((uint32_t)(((x)&0xF) << 0)) 
#define EXTMEM_FERR(x)                 ((uint32_t)(((x)&0xF) << 3)) 
#define INTMEM_CERR(x)                 ((uint32_t)(((x)&0xF) << 6)) 
#define INTMEM_FERR(x)                 ((uint32_t)(((x)&0xF) << 9)) 
#define INTMEM_SCR_CERR(x)             ((uint32_t)(((x)&0xF) << 12)) 
#define INTMEM_SCR_FERR(x)             ((uint32_t)(((x)&0xF) << 15)) 
#define CACHE_CRC_ERR(x)               ((uint32_t)(((x)&0xF) << 18)) 
                                                                                   

/**
 * @brief Макросы для регистра CACHE_MAIN
 */
#define CACHE_ENABLE(x)                       ((uint32_t)((x)<< 0))                  /**< 1 - запрос на включение, инициализацию; 0 - выключен*/
#define CACHE_READY(x)                        ((uint32_t)((x)<< 1))                  /**< 1 - готов, включен; 0 - нет */

/**
 * @brief	Разрешение прерывания
 * @param	IRQn	: Номер прерывания
 */
void NVIC_EnableIRQ(IRQn_T IRQn,uint32_t vec);


#define NVIC_En_IRQ(X)          *((volatile unsigned int *)(0xE000E100 + ((X)>>5)*4)) = (1<<((X)%32)); ///< X - вектор прерывания
#define NVIC_Dis_IRQ(X)         *((volatile unsigned int *)(0xE000E180 + ((X)>>5)*4)) = (1<<((X)%32)); ///< X - вектор прерывания


/**
 *\brief  Структура для доступа к регистрам управления прерываниями
 */
typedef struct 
{
    __RW uint32_t ISER[8];                                                      /**< Смещение: 0x000 Регистр разрешения прерываний */         
    uint32_t RESERVED0[24];                                          
    __RW uint32_t ICER[8];                                                      /**< Смещение: 0x080 Регистр запрещения прерываний */         
    uint32_t RESERVED1[24];                                          
    __RW uint32_t ISPR[8];                                                      /**< Смещение: 0x100 Регистр установки флагов прерываний */          
    uint32_t RESERVED2[24];                                                                  
    __RW uint32_t ICPR[8];                                                      /**< Смещение: 0x180 Регистр сброса флагов прерываний */        
    uint32_t RESERVED4[88];                                                                  
    __RW uint8_t  IP[240];                                                      /**< Смещение: 0x300 Регистры установки приоритета прерываний */ 
}NVIC_T;

/** \brief  Структура для доступа к регистрам системного таймера
 */
typedef struct 
{
    __RW uint32_t CTRL;                                                         /**< Смещение: 0x000 Регистр управления и статуса */
    __RW uint32_t LOAD;                                                         /**< Смещение: 0x004 Регистр для загрузки значений */
    __RW uint32_t VAL;                                                          /**< Смещение: 0x008 Регистр текущее значение */
    __RO  uint32_t CALIB;                                                       /**< Смещение: 0x00C Калибрационный регистр */
} SYSTICK_T;  

/** \brief  Структура для доступа к регистрам системного контроля
 */
typedef struct 
{
    __RO  uint32_t CPUID;                                                       /**< Смещение: 0x000 Регистр CPUID */
    __RW uint32_t ICSR;                                                         /**< Смещение: 0x004 Регистр управления и состояния прерываний */
    __RW uint32_t AIRCR;                                                        /**< Смещение: 0x00С Регистр управления и состояния прерываний приложения */
    __RW uint32_t SCR;                                                          /**< Смещение: 0x010 Регистр управления системой */
    __RO  uint32_t CCR;                                                         /**< Смещение: 0x014 Регистр управления и конфигурирования */
    __RW uint32_t SHPR2;                                                        /**< Смещение: 0x01С Регистр 2 приоритетов обработчика */
    __RW uint32_t SHPR3;                                                        /**< Смещение: 0x020 Регистр 3 приоритетов обработчика */
} SCB_T;                                                                    



/** \brief  Номера модулей в регистрах PWR_CLK_CTRL и PWR_RST_CTRL
 *Расшифровка битовых полей для регистров PWR_CTRL_CLK и PWR_CTRL_RST,
 *каждый бит соответствует включению одного модуля:
 *0 – SPI_1	13 – Telecommand Decoder (TCRX)
 *1 – SPI_2	14 – FPU
 *2 – UART_1	
 *3 – UART_2	
 *4 — UART_3	
 *5 — UART_4	
 *6 – Spacewire_1	
 *7 – Spacewire_2	20 — CAN_1
 *8 – MKPD1	21 — CAN_2
 *9 – MKPD2	22 — UART_5
 *10 – MKPD3	23 — UART_6
 *11 – MKPD4	24 — I2C
 *12 – Telemetry Encoder (TMTX)	25-31 – не используются
 */
typedef enum 
{
    SPI_1_CTRL_NUM                   = 0,                                        /**< номер модуля таймера общего назначения */ 
    SPI_2_CTRL_NUM                   = 1,                                        /**< номер модуля сторожевого таймера */ 
    UART_1_CTRL_NUM                  = 2,                                        /**< номер модуля UART 1 */
    UART_2_CTRL_NUM                  = 3,                                        /**< номер модуля UART 2 */
    UART_3_CTRL_NUM                  = 4,                                        /**< номер модуля UART 3 */
    UART_4_CTRL_NUM                  = 5,                                        /**< номер модуля UART 4 */
    Spacewire_1_CTRL_NUM             = 6,                                        /**< номер модуля SpaceWire 1 */  
    Spacewire_2_CTRL_NUM             = 7,                                        /**< номер модуля SpaceWire 2 */  
    MKPD1_CTRL_NUM                  = 8,                                        /**< номер модуля Manhester 0 */ 
    MKPD2_CTRL_NUM                 = 9,                                         /**< номер модуля Manhester 1 */ 
    MKPD3_CTRL_NUM                  = 10,                                       /**< номер модуля Manhester 2 */ 
    MKPD4_CTRL_NUM                 = 11,                                        /**< номер модуля Manhester 3 */
    TMTX_CTRL_NUM                = 12,                                          /**< номер модуля TMTX */
    TCRX_CTRL_NUM                = 13,                                          /**< номер модуля TCRX */
    FPU_CTRL_NUM                 = 14,                                          /**< номер модуля FPU */
    RES_P1_CTRL_NUM               =15,                                          /**< Резерв */
    RES_P2_CTRL_NUM               =16,                                          /**< Резерв */
    RES_P3_CTRL_NUM               =17,                                          /**< Резерв */
    RES_P4_CTRL_NUM               =18,                                          /**< Резерв */
    RES_CTRL_NUM                 =19,                                           /**< Резерв */
    CAN_1_CTRL_NUM               =20,                                           /**< номер модуля CAN1 */
    CAN_2_CTRL_NUM               =21,                                           /**< номер модуля CAN2 */
    UART_5_CTRL_NUM              = 22,                                          /**< номер модуля UART 5 */
    UART_6_CTRL_NUM              = 23,                                          /**< номер модуля UART 6 */
    I2C_CTRL_NUM                 =24
} CTRL_T;

/**
 * @brief	Разрешение прерывания
 * @param	IRQn	: Номер прерывания
 */

/**
 * @brief	Запрещение прерывания
 * @param	vec	: Номер вектора прерывания
 */
void NVIC_DisableIRQ(uint32_t vec);

/**
 * @brief Макросы для регистра SYSTICK CTRL
 */
#define SYST_CTRL_EN                         ((uint32_t)(1 << 0))               /**< включение таймера */ 
#define SYST_CTRL_INT_EN                     ((uint32_t)(1 << 1))               /**< включение прерывания таймера */ 
#define SYST_CTRL_CLKSRC_REF                 ((uint32_t)(0 << 2))               /**< использование внешнего тактового сигнала для таймера */ 
#define SYST_CTRL_CLKSRC_CPU                 ((uint32_t)(1 << 2))               /**< использование процессорного тактового сигнала для таймера */ 
#define SYST_CTRL_COUNTFL                    ((uint32_t)(1 << 16))              /**< маска для получения состояния флага, который устанавливается в 1, если таймер достиг 0 с момента последнего чтения этого регистра */ 

/**
 * @brief Макросы для регистра SYSTICK LOAD
 */
#define SYST_LOAD(x)                         ((uint32_t)((x) & 0xFFFFFF))       /**< значения для загрузки в VAL, если таймер включен и достиг 0*/ 

/**
 * @brief Макросы для регистра SYSTICK VAL
 */
#define SYST_VAL(x)                          ((uint32_t)((x) & 0xFFFFFF))       /**< текущее значение таймера*/ 

/**
 * @brief Макросы для регистра SYSTICK VAL
 */
#define SYST_CALIB_TENMS(x)                  ((uint32_t)((x) & 0xFFFFFF))       /**< значение для 10мс (100Hz), с учетом погрешностей системного клока */ 
#define SYST_CALIB_SKEW                      ((uint32_t)(1 << 30))              /**< маска для получения значения бита, определяющего, задано ли SYST_CALIB_TENMS */ 
#define SYST_CALIB_NOREF                     ((uint32_t)(1 << 31))              /**< маска для получения значения бита, определяющего, есть ли у процессора референсный тактовый сигнал */ 

/**
 * @brief Макросы для регистра SCB CPUID
 */
#define SCB_CPUID_IMP(x)                     ((uint32_t)(((x)  >> 0) & 0xF))    /**< код производителя */ 
#define SCB_CPUID_VAR(x)                     ((uint32_t)(((x) >> 4) & 0xFFF))   /**< номер варианта (r) в идентификаторе версии продукта rnpn */ 
#define SCB_CPUID_CONST(x)                   ((uint32_t)(((x) >> 16) & 0xF))    /**< код архитектуры */ 
#define SCB_CPUID_PRTN(x)                    ((uint32_t)(((x) >> 20) & 0xF))    /**< номер процессора */ 
#define SCB_CPUID_REV(x)                     ((uint32_t)(((x) >> 24) & 0xFF))   /**< номер ревизии (p) в идентификаторе версии продукта rnpn */ 

/**
 * @brief Макросы для регистра SCB ICSR
 */
#define SCB_ICSR_VECTACTIVE(x)               ((uint32_t)(((x) >> 0) & 0x1F))     /**< номер активного исключения */ 
#define SCB_ICSR_VECTPENDING(x)              ((uint32_t)(((x) >> 12) & 0x1F))   /**< номер ожидакющего исключения с самым высоким приоритетом */ 
#define SCB_ICSR_ISRPENDING                  ((uint32_t)(1 << 22))              /**< маска для получения состояния ожидакющего исключения */ 
#define SCB_ICSR_PENDSTCLR                   ((uint32_t)(1 << 25))              /**< сброс прерывания от SYSTICK */ 
#define SCB_ICSR_PENDSTSET                   ((uint32_t)(1 << 26))              /**< установка прерывания от SYSTICK */ 
#define SCB_ICSR_PENDSVCLR                   ((uint32_t)(1 << 27))              /**< сброс прерывания PendSV */ 
#define SCB_ICSR_PENDSVSET                   ((uint32_t)(1 << 28))              /**< установка прерывания PendSV */ 
#define SCB_ICSR_NMIPENDSET                  ((uint32_t)(1 << 31))              /**< установка прерывания NMI */ 

/**
 * @brief Макросы для регистра SCB AIRCR
 */
#define SCB_AIRCR_VECTKEY                    ((uint32_t)((0x05FA) << 16))       /**< ключ регистра, необходимо установить для записи */ 
#define SCB_AIRCR_ENDIANESS                  ((uint32_t)(1 << 15))              /**< маска для получения эндианности */ 
#define SCB_AIRCR_SYSRESETREQ                ((uint32_t)(1 << 2))               /**< запрос перезагрузки системы */ 
#define SCB_AIRCR_VECTCLRACTIVE              ((uint32_t)(0 << 1))               /**< установить в ноль для запсиси */ 

/**
 * @brief Макросы для регистра SCB SCR
 */
#define SCB_SCR_SEVONPEND                    ((uint32_t)(1 << 4))               /**< выход из режима сна по прерываниям и разрешенным событиям */ 
#define SCB_SCR_SLEEPDEEP                    ((uint32_t)(1 << 2))               /**< установка глубокого сна в качестве режима сна */ 
#define SCB_SCR_SLEEPONEXIT                  ((uint32_t)(1 << 1))               /**< переход в режим сна после выхода из обработчика прерываний */ 

/**
 * @brief Макросы для регистра SCB SHPR2
 */
#define SCB_SHPR2_PRI_11(x)                  ((uint32_t)(((x) & 0x3) << 30))    /**< установка приоритета обработчика SVCall */ 

/**
 * @brief Макросы для регистра SCB SHPR3
 */
#define SCB_SHPR3_PRI_14(x)                  ((uint32_t)(((x) & 0x3) << 22))    /**< установка приоритета обработчика PendSV */ 
#define SCB_SHPR3_PRI_15(x)                  ((uint32_t)(((x) & 0x3) << 30))    /**< установка приоритета обработчика SysTick */ 



              

/**
 * @brief Макросы для регистра ALTFUNC_CTRL
 */
#define PORT_A_ALTFUNC                          0                               /**< альтернативная функция PORT_A */
#define PORT_B_ALTFUNC                          1                               /**< альтернативная функция PORT_B */
#define PORT_C_ALTFUNC                          2                               /**< альтернативная функция PORT_C */
#define PORT_D_ALTFUNC                          3                               /**< альтернативная функция PORT_D */
#define PORT_E_ALTFUNC                          4                               /**< альтернативная функция PORT_E */
#define PORT_F_ALTFUNC                          5                               /**< альтернативная функция PORT_F */
#define PORT_G_ALTFUNC                          6                               /**< альтернативная функция PORT_G */
#define PORT_H_ALTFUNC                          7                               /**< альтернативная функция PORT_H */
#define PORT_I_ALTFUNC                          8                               /**< альтернативная функция PORT_I */

#define ALTFUNC_CTRL_EXTMEM_EDAC_CERR_EN        ((uint32_t)(1 << 0))            /**< альтернативная функция MKPD4_TX/GPIOF[14] */

#define ALTFUNC_CTRL_EXTMEM_EDAC_FERR_EN        ((uint32_t)(1 << 1))            /**< альтернативная функция MKPD4_nTX/GPIOF[15] */

#define ALTFUNC_CTRL_INTMEM_EDAC_CERR_EN        ((uint32_t)(1 << 2))            /**< альтернативная функция MKPD4_TXEN_A/GPIOG[0] */

#define ALTFUNC_CTRL_INTMEM_EDAC_CERR_2_EN      ((uint32_t)(1 << 3))            /**< альтернативная функция SW_SOUT[1]/GPIOG[10] */

#define ALTFUNC_CTRL_INTMEM_EDAC_FERR_2_EN      ((uint32_t)(1 << 4))            /**< альтернативная функция SW_DOUT[1]/GPIOG[11] */

#define ALTFUNC_CTRL_BITMASK                    ((uint32_t)(0x1F << 0))         /**< альтернативная функция маска*/

#define SET_ALTFUNC(PORT, BIT, FUNC) CMN_REG->ALT_FUNCTION_CTRL[PORT] = (CMN_REG->ALT_FUNCTION_CTRL[PORT] & (~(3 << (2 * (BIT))))) | ((FUNC) << (2 * (BIT)))  /**< установить альтернативную функцию */


/**
 * @brief Макросы для регистра MKPD_CLK_CTRL
 */
#define MKPD_CLK_CTRL_TX(x)                     ((uint32_t)((x) & 0xFF) << 0)   /**< коэффициента деления тактовой системной частоты для передатчиков всех блоков МКПД */ 

#define MKPD_CLK_CTRL_RX(x)                     ((uint32_t)((x) & 0xFF) << 8)   /**< коэффициента деления тактовой системной частоты, для приемников всех блоков МКПД */ 

#define MKPD_CLK_SPW_CLK_EN                     ((uint32_t)(1 << 16))           /**< альтернативная функция SW_DOUT[1]/GPIOG[11] */

/**
 * @brief	Подача тактового сигнала на модуль
 * @param	CTRLn	: Номер модуля
 */
void PWR_CLK_Enable(CTRL_T CTRLn);
/**
 * @brief	Отключение тактового сигнала от модуля
 * @param	CTRLn	: Номер модуля
 */
void PWR_CLK_Disable(CTRL_T CTRLn);
/**
 * @brief	Вывод модуля из асинхронного сброса 
 * @param	CTRLn	: Номер модуля
 */
void PWR_RST_Disable(CTRL_T CTRLn);

/**
 * @brief	Ввод модуля в асинхронный сброс
 * @param	CTRLn	: Номер модуля
 */
void PWR_RST_Enable(CTRL_T CTRLn);

/**
 * @brief	Инициализация микросхемы
 */
void SystemInit(void);

#endif

#ifdef __cplusplus
}
#endif

