/*!\file
 * \brief Этот файл содержит структуры, макросы и функции, необходимые для взаимодействия с кольцевыми буферами.
 *
 * Copyright(C) НПП Цифровые решения, 2018
 * Copyright(C) Команда разработчиков НПП Цифровые решения
 * Все права защищены.
 *
 * Программное обеспечение, описанное в этом файле, предназначено только для 
 * демонстрационных целей, и предоставляет программистам информацию о продукции 
 * организации "Цифровые решения". Это программное обеспечение поставляется "КАК ЕСТЬ" 
 * без каких-либо гарантий, "Цифровые решения" отказываются от любых гарантий, 
 * фактических или подразумеваемых, включая все подразумеваемые гарантии товарной пригодности, 
 * пригодности для конкретной цели и сохранения прав интеллектуальной собственности. 
 * Организация "Цифровые решения" не несет никакой ответственности за использование 
 * программного обеспечения, не предоставляет лицензий или прав на патент, авторское право, 
 * или любые другие права интеллектуальной собственности, на какие-либо продукты. 
 * Организация "Цифровые решения" оставляет за собой право вносить изменения в программное 
 * обеспечение без уведомления. Организация "Цифровые решения" также не дает никаких 
 * заверений или гарантий, что это программное приложение подойдет для использования 
 * без дальнейшего тестирования или модификаций.
 *
 * Разрешение на использование, копирование, изменение и распространение этого программного 
 * обеспечения и документации предоставляется согласно условиям "Цифровых решений" и 
 * соответствующих авторских прав своей лицензии без оплаты, при условии, 
 * что это программное обеспечение используется совместно с микроконтроллерами организации
 * "Цифровые решения". Эти права должны распространяться во всех копиях этого кода.
 */

#ifndef __RING_BUFFER_H_
#define __RING_BUFFER_H_

#include <string.h>   
#include "types.h"


/**
 * @brief Структура кольцевого буфера
 */
typedef struct 
{
    void *data;                                                                 /**< Указатель на буфер */ 
    int count;                                                                  /**< Размер буфера в байтах */
    int itemSz;                                                                 /**< Размер элемента буфера */
    uint32_t head;                                                              /**< Индекс для чтения */
    uint32_t tail;                                                              /**< Индекс для записи */
}RINGBUFF_T;

/**
 * @brief Макросы для работы с кольцевыми буферами
 */
#define RB_INDH(gl_rb_t)     ((gl_rb_t)->head & ((gl_rb_t)->count - 1))
#define RB_INDT(gl_rb_t)     ((gl_rb_t)->tail & ((gl_rb_t)->count - 1))
#define RB_VHEAD(gl_rb_t)    (*(volatile uint32_t *) &(gl_rb_t)->head)          /**< Переобъявление индекса, указывающего на место для записи в буфер, как volatile */
#define RB_VTAIL(gl_rb_t)    (*(volatile uint32_t *) &(gl_rb_t)->tail)          /**< Переобъявление индекса, указывающего на место для чтения из буфера, как volatile */
#define	RB_FLUSH(gl_rb_t)    (((RINGBUFF_T *)gl_rb_t)->head = ((RINGBUFF_T *)gl_rb_t)->tail=0) /**< Сброс кольцевого буфера */  

/**
 * @brief Инициализация кольцевого буфера.
 * @param RingBuff: указатель на структуру кольцевого буфера
 * @param buffer: указатель на буфер, который будет использоваться в качестве кольцевого
 * @param itemSize: размер элемента буфера 
 * @param count: размер буфера
 * @retval None
 */
void RingBuffer_Init(RINGBUFF_T *RingBuff, void *buffer, int itemSize, int count);

/**
 * @brief Запись одного элемента в кольцевой буфер.
 * @param RingBuff: указатель на структуру кольцевого буфера
 * @param data: указатель на элемент
 * @retval Статус операции
 */
Status RingBuffer_Insert(RINGBUFF_T *RingBuff, const void *data);

/**
 * @brief Запись нескольких элементов в кольцевой буфер.
 * @param RingBuff: указатель на структуру кольцевого буфера
 * @param data: указатель на первый элемент элемент в массиве для записи
 * @param num: размер массива
 * @retval (cnt1 + cnt2): число успешно записанных элементов, 0 в случае ошибки
 */
int RingBuffer_InsertMult(RINGBUFF_T *RingBuff, const void *data, int num);

/**
 * @brief Чтение одного элемента из кольцевого буфера
 * @param RingBuff: указатель на структуру кольцевого буфера
 * @param data: указатель на массив, для хранения прочитанного элемента
 * @retval Статус операции
 */
Status RingBuffer_Pop(RINGBUFF_T *RingBuff, void *data);

/**
 * @brief Чтение массива элементов из кольцевого буфера
 * @param RingBuff: указатель на структуру кольцевого буфера
 * @param data: указатель на массив, для хранения прочитанных элемента
 * @param num: максимальное число элементов, которое можно сохранить в массиве
 * @retval (cnt1 + cnt2): число успешно прочитанных элементов, 0 в случае ошибки
 */
int RingBuffer_PopMult(RINGBUFF_T *RingBuff, void *data, int num);

/**
 * @brief Получение размера кольцевого буфера в байтах.
 * @param RingBuff: указатель на структуру кольцевого буфера
 * @retval Размер кольцевого буфера в байтах
 */
 int RingBuffer_GetSize(RINGBUFF_T *RingBuff);

/**
 * @brief Получения количества элементов, записанных в кольцевой буфер.
 * @param RingBuff: указатель на структуру кольцевого буфера
 * @retval Количество элементов, записанных в кольцевой буфер
 */
 int RingBuffer_GetCount(RINGBUFF_T *RingBuff);

/**
 * @brief Получение размера свободного места в кольцевом буфере
 * @param RingBuff: указатель на структуру кольцевого буфера
 * @retval Размер свободного места в кольцевом буфере
 */
 int RingBuffer_GetFree(RINGBUFF_T *RingBuff);

/**
 * @brief Проверка на наличие свободного места в кольцевом буфере
 * @param RingBuff: указатель на структуру кольцевого буфера
 * @retval 1 если кольцевой буфер заполнен, иначе 0
 */
 int RingBuffer_IsFull(RINGBUFF_T *RingBuff);

/**
 * @brief Проверка кольцевого буфера на отсутствие данных
 * @param RingBuff: указатель на структуру кольцевого буфера
 * @retval 1 если кольцевой буфер пуст, иначе 0
 */
 int RingBuffer_IsEmpty(RINGBUFF_T *RingBuff);


#endif /* __RING_BUFFER_H_ */
