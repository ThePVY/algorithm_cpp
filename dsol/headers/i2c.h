/*!\file
 * \brief Этот файл содержит структуры, макросы и функции, необходимые для взаимодействия с интерфесом I2C.
 *
 * Copyright(C) НПП Цифровые решения, 2018
 * Copyright(C) Команда разработчиков НПП Цифровые решения
 * Все права защищены.
 *
 * Программное обеспечение, описанное в этом файле, предназначено только для 
 * демонстрационных целей, и предоставляет программистам информацию о продукции 
 * организации "Цифровые решения". Это программное обеспечение поставляется "КАК ЕСТЬ" 
 * без каких-либо гарантий, "Цифровые решения" отказываются от любых гарантий, 
 * фактических или подразумеваемых, включая все подразумеваемые гарантии товарной пригодности, 
 * пригодности для конкретной цели и сохранения прав интеллектуальной собственности. 
 * Организация "Цифровые решения" не несет никакой ответственности за использование 
 * программного обеспечения, не предоставляет лицензий или прав на патент, авторское право, 
 * или любые другие права интеллектуальной собственности, на какие-либо продукты. 
 * Организация "Цифровые решения" оставляет за собой право вносить изменения в программное 
 * обеспечение без уведомления. Организация "Цифровые решения" также не дает никаких 
 * заверений или гарантий, что это программное приложение подойдет для использования 
 * без дальнейшего тестирования или модификаций.
 *
 * Разрешение на использование, копирование, изменение и распространение этого программного 
 * обеспечения и документации предоставляется согласно условиям "Цифровых решений" и 
 * соответствующих авторских прав своей лицензии без оплаты, при условии, 
 * что это программное обеспечение используется совместно с микроконтроллерами организации
 * "Цифровые решения". Эти права должны распространяться во всех копиях этого кода.
 */

#ifndef I2C_H
#define I2C_H

#include "types.h"
#include "chip_5023BC016.h"
#include "system.h"
#include "gpio.h"  


/**
 * @brief Структура для доступа к регистрам I2C.
 */

/**
 * @brief Структура для доступа к регистрам блока I2C-мастер
 */
typedef struct
{
    __RW uint32_t Clock_prescale;                                               /**<Смещение: 0x00 Регистр предделителя */
    __RW uint32_t Control;                                                      /**<Смещение: 0x04 Регистр управления */
    __RW uint32_t Tx_Rx;                                                        /**<Смещение: 0x08 Регистр переданных и принятых данных */
    __RW uint32_t Com_Stat;                                                     /**<Смещение: 0x0C Регистр команд и статуса */
}I2C_T;


/**
 * @brief Макросы и типы для регистра Clock_prescale
 */
#define Prescale(x)      ((uint32_t)(((x)&0xFFFF) << 0))                          /**<Значение используется для задания периода тактового сигнала на линии SCL. 
                                                                                    Значение может быть изменено только если бит EN в регистре Control установлен в 0. 
                                                                                    Минимальное рекомендуемое значение этого поля равно 3*/

/**
 * @brief Макросы и типы для регистра Control
 */
#define IEN(x)           ((uint32_t)((x) << 6))                                   /**<1 – Включение прерывания, происходящего по завершению транзакции*/
#define EN(x)            ((uint32_t)((x) << 7))                                   /**<1 – Перевод блока I2C в рабочий режим */


/**
 * @brief Макросы и типы для регистра Tx_Rx
 */
#define RW(x)            ((uint32_t)((x) << 0))                                   /**<Значение данного бита определяет направление транзакции. 1 – чтение из подчиненного устройства, 0 – запись в подчиненное устройство*/    
#define TDATA(x)         ((uint32_t)(((x)&0x7F) << 1))                            /**<Данные для передачи. Старшие 7 бит слова данных, которые будут переданы по шине I2C*/
#define RDATA(x)         ((uint32_t)(((x)&0xFF) << 0))                            /**<Последний байт, принятый по шине I2C*/                    

/**
 * @brief Макросы и типы для регистра Com_Stat
 */
#define IACK_IF(x)       ((uint32_t)((x) << 0))                                   /**<Очищает флаг прерывания (IF)  в регистре Com_Stat
                                                                                    Бит выставляется, когда транзакция завершена, либо когда теряется арбитрация.*/         

#define TIP(x)          ((uint32_t)((x) << 1))                                    /**<Имеет значение 1, когда происходит передача данных и 0 – когда транзакция завершается.*/

#define ACK(x)          ((uint32_t)((x) << 3))                                    /**<Используется, когда мастер является приемником. 0 – послать ACK, 1 – послать NACK*/         

#define WR(x)           ((uint32_t)((x) << 4))                                    /**<Запись в подчиненное устройство*/         

#define RD_AL(x)        ((uint32_t)((x) << 5))                                    /**<Чтение из подчиненного устройства.
                                                                                    Устанавливается в 1, когда блок потерял арбитрацию*/  

#define STO_BUSY(x)     ((uint32_t)((x) << 6))                                    /**<Генерация условия STOP на шине.
                                                                                    Бит выставляется в 1 если на шине было обнаружено условие START 
                                                                                    и сбрасывается в 0 если на шине было обнаружено условие STOP*/  

#define STA_RxACK(x)    ((uint32_t)((x) << 7))                                    /**<Генерация условия START на шине, либо повторного условия START.
                                                                                    Принятое значение бита подтверждения (acknowledge). 
                                                                                    0 – подчиненное устройство подтвердило транзакцию, 1 – подтверждение не было получено*/  

#define IF(x)           ((uint32_t)((x) << 0))                                    /**<Бит выставляется, когда транзакция завершена, либо когда теряется арбитрация. 
                                                                                    Если установлен бит IEN в регистре Control, в этот момент будет сгенерировано прерывание. */      

/**
 * @brief Макросы и типы для работы с I2C
 */
#define I2C_ENABLE 0x80

/**
 * @brief Инициализация I2C.
 * @param pI2C: указатель на структуру с регистрами I2C.
 * @param clt_prsc: делитель частоты I2C.
 * @retval None.
 */
void I2C_Init(I2C_T *pI2C, uint32_t clt_prsc);

/**
 * @brief Инициализация портов в режиме альтернативной функции для работы I2C.
 * @param pI2C: None.
 * @retval None.
 */
void I2C_GPIO_Init();

/**
 * @brief Отправка байта по интерфейсу I2C.
 * @param addr: адрес устройства I2C.
 * @param data: байт для передачи.
 * @retval Zero or error.
 */
unsigned int I2C_Write_Byte(unsigned char addr, unsigned char data);

/**
 * @brief Чтение байта по интерфейсу I2C.
 * @param addr: адрес устройства I2C.
 * @param data: принятый байт.
 * @retval Zero or error.
 */
unsigned int I2C_Read_Byte(unsigned char addr, unsigned char *data);

/**
 * @brief Запись данных по интерфейсу I2C.
 * @param ch_dev: адрес устройства I2C.
 * @param data: указатель на отправляемые данные
 * @param len: количество данных
 * @retval None.
 */
void I2C_WriteData(unsigned char ch_dev, unsigned char* data, unsigned int len);

/**
 * @brief Чтение данных по интерфейсу I2C.
 * @param ch_dev: адрес устройства I2C.
 * @param data: указатель - расположение принятых данных
 * @param len: количество данных
 * @retval None.
 */
void I2C_ReadData(unsigned char ch_dev, unsigned char* data, unsigned int len);




#endif /* I2C_H */